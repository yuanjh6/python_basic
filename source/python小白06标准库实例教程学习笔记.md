# python小白06标准库实例教程学习笔记
## 文本处理
 textwrap：文本段落格式化  
re：正则表达式  
difflib：字符比较  

## 数据结构  
bisect 模块里实现了一个向列表插入元素时也会顺便排序的算法。  
struct — 二进制数据结构：用途：在 Python 基本数据类型和二进制数据之间进行转换。  
heapq – 堆排序算法：heapq 实现了适用于 Python 列表对象的最小堆排序算法。  
queue — 线程安全的 FIFO 队列：提供线程安全的 FIFO 实现，LIFO Queue （后进先出型队列），Priority Queue （优先队列）  
weakref — 实现对象的弱引用；用途：提供对象的引用，当没有其他强引用时，对象会被垃圾回收。  
copy — 对象复制；用浅复制或深复制的语义来为对象提供复制函数。  
  
## 算法  
functools — 函数操作工具箱  
partial：装饰器  
获得装饰器（ Decorator ）的函数属性：wraps() ，它将 update_wrapper() 装饰到了函数中  
对比：total_ordering() 类装饰器为类提供了一些方法可以为我们自动添加其余我们没有添加的对比方法。  
缓存：lru_cache() 装饰器会让某函数具有最近最小缓存机制。所有传递过来的参数都会被哈希化，用于后续结果的映射。之后再次调用相同的参数时会从缓存中直接调取出结果而不再经过函数运算。同时此装饰器还给原函数加了一个用于检测缓存状态的方法（cache_info()）和一个清空缓存的方法（cache_clear()）。  
生成数据集合：reduce() 函数可接受一个可调用的数据序列，并且基于序列中的值不断经由一个可调用的对象处理，最后生成一个总值。  
泛型函数：在动态类型语言（如 Python）中，经常有在执行时需要辨别不同类型的参数的需求，比如要处理的是一个列表里的数据还是一个单个的数据。直接检测参数的类型当然简单，但不同的功能也可以写到不同的函数中，所以 functools 提供了 singledispatch() 装饰器来让我们注册 泛型函数 以自动基于类型进行切换。  
  
合并与分割迭代器：chain() 函数将几个迭代器作为参数，并返回一个迭代器。这个迭代器将会依次遍历那些作为输入的迭代器。  
内置函数 zip() 返回一个迭代器，这个迭代器将同时遍历多个输入迭代器，并返回一个由在这些迭代器中得到的元素所组合成的元祖。  
如果想完整的遍历所有的输入迭代器（即使它们有不同的长度），我们可以用 zip_longest() 函数。  
islice() 函数将把输入迭代器的一部分作为其输出的迭代器。：islice() 和 slice 操作一样，将 start，stop 以及 step 作为输入参数。其中 start 和 step 参数是可选的。  
tee() 函数返回多个（默认两个）独立的迭代器。  
  
变换输入：  
内置函数 map() 会将一个函数分别作用到输入的一个迭代器的每个元素数，并将其以迭代器的形式返回。这个迭代器会遍历完这个输入的迭代器。  
starmap() 这个函数和 map() 的作用很相似。但是 map() 函数的输入实际上是由多个（或单个）迭代器组成的元组，而 starmap() 遍历的是一个返回元组的单个迭代器。它会用 * 记号把元组分离成参数列表传入函数。  
也就是说，对 map() 函数来说，它可以有多个参数 (i1, i2)，然后返回 f(i1, i2)。但对于 starmap() 来说，输入只有一个元组 i，它返回的是 f(*i)。  
  
产生新的值  
count() 函数返回一个产生一列连续整数的迭代器。我们可以传递一个参数来设定起始值。与内置函数 range() 不同，不需要给出一个参数来设定上限。  
repeat() 函数返回的迭代器会把一个值重复几次输出。  
  
过滤  
dropwhile() 函数返回一个迭代器，其中的元素为原迭代器中，给定条件首次为假之后的所有元素。  
与 dropwhile() 相对的是 takewhile()。它将原迭代器中，直到给定条件为假之前的所有元素，作为新的迭代器返回。  
内建函数 filter() 返回一个迭代器，只包含使测试函数为真的所有元素。  
与 dropwhile() 和 takewhile() 不同的是，filter() 返回前，所有元素都会被测试。  
filterfalse() 返回一个迭代器，其中只包含使测试函数为假的所有元素。  
compress() 提供了另一种方法来过滤序列。它不是调用一个测试函数，而是使用另外一个序列中的值来决定元素的取舍。  
  
数据分组  
groupby() 函数返回一个迭代器，其中的每个元素是有一个共同的键的一组值。这个例子中展示了根据一个属性来对相关数据进行分组的方法。  
  
联结输入  
accumulate() 函数将输入序列的第 n 和第 n+1 个元素传入给定函数，产出返回值。缺省情况下，函数将返回两个输入参数的和， 所以 accumulate() 可以用来得到一个数字序列的累加和。  
若用在非整数序列上，结果取决于加操作对两个元素的意义。此代码中第二个例子展示了当 accumulate() 输入为字符串时，返回的结果为此字符串逐次变长的前缀部分。  
你可以将 accumulate() 与任何接受两个参数的函数一起使用，来得到不同的结果。  
  
product() 常用来取代对多个序列的嵌套 for 循环，返回一个包含所有输入组合的笛卡儿积的迭代器。  
permutations() 函数产出输入序列的所有给定长度的排列。默认返回全排列（与原序列长度相等）。  
要返回所有不重复的组合而不是排列，使用 combinations()。如果输入序列的所有元素都不重复，输入中将不会有任何重复的值。  
由于 combinations() 不会重复输入序列的元素，而有时又需要考虑包含重复元素的组合，对于这种情况，使用 combinations_with_replacement().(base)   
  
## 文件系统  
os.path — 跨平台的文件名操作  
os.sep - 路径各部分之间的分隔符 （例如， 「/」或者 「\」）。  
os.extsep - 文件名和 「扩展名」之间的分隔符 （例如， 「.」）。  
os.pardir - 表示上级目录的路径组件（例如， 「..」）。  
os.curdir - 表示当前目录的路径组件（例如， 「.」）。  
  
split 函数用于将路径分割成两部分，它会返回一个表示结果的 tuple。tuple 的第二个元素是路径的最后一部分，第一个元素是之前的所有信息。  
当输入的参数是以 os.sep 结尾时，路径的最后一个元素就是空的字符串。  
basename() 函数会返回一个等同于 split() 函数第二部分的值。  
dirname() 函数会返回一个等同于 split() 函数第一部分的值。  
将 basename() 于 dirname() 的结果组合起来，就会得到原始的路径  
commonpath() 充分考虑路径分隔符，会返回路径序列中各个部分的最长公共有效子路径。  
commonprefix()  函数会接受一个路径列表作为参数而返回一个字符串表示所有路径中的公共前缀。这个字符串可能表示一个实际不存在的路径，因为路径分隔符并没有被考虑在内，所以这个公共前缀可能并没有落在分隔符边界上。  
  
构建路径  
除了将现有路径分开之外，通常还需要从其他字符串构建路径。为了将几个路径组件组合成一个单个的值，可以使用 join()：  
规范路径  
使用 join() 或者嵌入变量的独立字符串组合的路径结尾可能有额外的路径分隔符或者相对路径组件。使用 normpath() 来清理他们：  
使用  abspath() 将相对路径转化为绝对路径。  
os.path.getatime() 返回文件最后访问时间， os.path.getmtime() 返回文件最后修改时间，  os.path.getctime() 返回文件创建时间。 os.path.getsize() 返回文件包含数据的大小，以字节表示。  
  
  
glob — 文件名规则匹配  
通配符：一个星号（ * ）匹配名称片段中零个或者多个字符，例如，dir/*。  
单字符通配符：问好（ ? ）是另一个通配符。它匹配文件名称中任何单个字符。  
字符范围：使用字符范围（ [a-z] ）而不是问号去匹配多个字符中的一个。这个例子中将会查找到所有在扩展名之前有一个数字的文件。  
转义元字符：有时候可能需要去查找一些包含 glob 模式使用的特殊字符的文件。escape() 方法会用转义后的特殊字符构建一个适配模式，这样 glob 就不会将它当做特殊字符解释处理。  
  
fnmatch — Unix 风格的 Glob 文件名规则匹配  
tempfile — 临时文件对象  
临时文件#  
命名临时文件  
缓冲文件  
临时目录  
预测名称  
临时文件位置  
  
shutil — 高阶文件操作  
复制文件  
copyfile() 复制源文件的内容到目标位置，如果没有创建新文件的权限将会引发 IOError  
copy2() 类似 copy() ，但是在复制时会包含元数据中的访问和修改时间。  
处理目录树  
shutil 模块提供了三个方法处理目录树。为了将目录从一个地方复制到另一个，请使用 copytree() 。它递归源目录内容，将每个文件复制到目标目录，目标目录事先必须存在。  
查找文件  
which() 方法会按照一个搜索路径查找文件。典型的使用场景是在环境变量 PATH 定义的路径中查找可执行程序的位置。  
压缩  
Python 标准库包含了许多模块用于管理压缩文件，例如 tarfile 和 zipfile。shutil 模块中也有几个高阶方法用于解压缩文件。get_archive_formats() 返回一个当前系统支持的格式名称以及描述列表。  
  
文件系统空间  
filecmp — 文件对比  
filecmp 模块包含函数和类来比较系统上的文件和文件夹  
  
mmap — 内存映射模块  
内存映射文件可视为可变字符串或类文件对象，取决于具体需要。一个被映射的文件支持文件 API 方法，例如， close() ， flush()， read()， rea  
文本、二进制和原生流的 I/O 工具  
StringIO  提供了使用文件 API （read()，write() 等）处理内存中的文本。在某些情况下，使用 StringIO 构建大型字符串可以比其他字符串连接技术节省性能。内存中的流缓冲区对测试也是很有用的，因为写入磁盘上的真实文件可能会降低测试套件的速度。  
  

## 应用程序组成元素  
argparse --- 命令行选项和参数解析  
getopt --- 命令行选项解析  
readline --- GNU readline 库  
getpass --- 安全密码提示  
cmd --- 面向行的命令处理器  
shlex --- 解析 Shell 样式的语法  
configparser --- 使用配置文件  
logging --- 报告状态、错误和信息性消息  
fileinput --- 命令行过滤器框架  
atexit --- 程序关闭回调  
sched --- 定时事件调度程序  
 
## 开发者工具  
pydoc：模块的线上帮助文档   
doctest：通过文档来测试   
unittest：自动化测试框架   
trace：跟踪代码执行流   
traceback：异常和调用堆栈跟踪   
cgitb：更加详细的 Traceback 报告   
pdb：交互式调试器   
profile and pstats：性能分析   
timeit：计算小段 Python 代码的运行时间   
tabnanny：缩进验证器   
compileall：将源码编译为字节码   
pyclbr：类浏览器   
venv：创建虚拟环境   
ensurepip：安装 Python 扩展安装器 pip  
